# Alembic Migrations Best Practices

Alembic is SQLAlchemy's database migration tool. This guide covers best practices for managing database schema changes.

## Basic Setup

### Initialization

```bash
# Initialize Alembic
alembic init alembic

# Create initial migration from models
alembic revision --autogenerate -m "Initial migration"

# Apply migrations
alembic upgrade head

# Rollback
alembic downgrade -1
```

### Configuration (alembic/env.py)

```python
from app.core.config import settings
from app.models import Base

# Set metadata for autogenerate: Alembic compares models to database.
target_metadata = Base.metadata

# Database URL from config: Remove async driver (Alembic uses sync connection).
config.set_main_option(
    "sqlalchemy.url",
    settings.DATABASE_URL.replace("+asyncpg", "")  # Remove async driver
)

# run_migrations_online: Runs migrations using async engine.
def run_migrations_online():
    # Use async engine: Create connection for migrations.
    connectable = create_async_engine(settings.DATABASE_URL)
    async with connectable.connect() as connection:
        # run_sync: Runs sync migration code in async context.
        await connection.run_sync(do_run_migrations)
    await connectable.dispose()  # Cleanup
```

## Migration Best Practices

### 1. Review Auto-Generated Migrations

```python
# ‚ùå Bad: Blindly accept autogenerate
alembic revision --autogenerate -m "Add user table"
# Always review and edit the generated migration!

# ‚úÖ Good: Review and edit autogenerated migrations (always review!).
def upgrade():
    # Create table: Review autogenerated code, add constraints/indexes as needed.
    op.create_table(
        'users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('email', sa.String(), nullable=False),
        sa.Column('created_at', sa.DateTime(), nullable=True),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('email')  # Add constraints explicitly
    )
    op.create_index('ix_users_email', 'users', ['email'], unique=True)

def downgrade():
    # Reversible: Always provide downgrade path (opposite order).
    op.drop_index('ix_users_email', table_name='users')
    op.drop_table('users')
```

### 2. Always Write Reversible Migrations

```python
# ‚úÖ Good: Reversible migration (can rollback if needed).
def upgrade():
    op.add_column('users', sa.Column('phone', sa.String(), nullable=True))
    op.create_index('ix_users_phone', 'users', ['phone'])

def downgrade():
    # Downgrade: Reverse order (drop index before column).
    op.drop_index('ix_users_phone', table_name='users')
    op.drop_column('users', 'phone')
```

### 3. Handle Data Migrations Separately

```python
# Migration 1: Schema change (separate from data migration).
def upgrade():
    op.add_column('users', sa.Column('full_name', sa.String(), nullable=True))

def downgrade():
    op.drop_column('users', 'full_name')

# Migration 2: Data migration (separate migration for data updates).
def upgrade():
    # Update existing data: Populate new column with computed values.
    connection = op.get_bind()
    connection.execute(
        "UPDATE users SET full_name = first_name || ' ' || last_name"
    )

def downgrade():
    # Revert data if needed: Usually can't fully revert data changes.
    pass
```

### 4. Use Transactions

```python
# Alembic wraps migrations in transactions by default
# Multiple operations succeed or fail together

def upgrade():
    op.create_table('orders', ...)
    op.create_table('order_items', ...)  # Both or neither
    op.add_column('users', ...)
```

### 5. Handle Production Data Carefully

```python
# Add column with default: Multi-step process for production safety.
def upgrade():
    # Step 1: Add nullable column (allows existing rows to have NULL initially).
    op.add_column('users', sa.Column('status', sa.String(), nullable=True))
    
    # Step 2: Set default for existing rows (populate before making NOT NULL).
    op.execute("UPDATE users SET status = 'active' WHERE status IS NULL")
    
    # Step 3: Make NOT NULL (separate migration for safety - do after data is populated).
    # op.alter_column('users', 'status', nullable=False)

def downgrade():
    op.drop_column('users', 'status')
```

## Common Migration Patterns

### Adding Indexes

```python
def upgrade():
    op.create_index(
        'ix_users_email_active',
        'users',
        ['email'],
        unique=True,
        postgresql_where=sa.text('deleted_at IS NULL')  # Partial index
    )

def downgrade():
    op.drop_index('ix_users_email_active', table_name='users')
```

### Renaming Columns

```python
def upgrade():
    op.alter_column('users', 'name', new_column_name='full_name')

def downgrade():
    op.alter_column('users', 'full_name', new_column_name='name')
```

### Changing Column Types

```python
def upgrade():
    # PostgreSQL
    op.execute('ALTER TABLE users ALTER COLUMN price TYPE DECIMAL(10,2) USING price::DECIMAL')
    
    # Or using Alembic
    op.alter_column('users', 'price', type_=sa.Numeric(10, 2))

def downgrade():
    op.alter_column('users', 'price', type_=sa.Float())
```

### Adding Foreign Keys

```python
def upgrade():
    op.add_column('orders', sa.Column('user_id', sa.Integer(), nullable=True))
    op.create_foreign_key(
        'fk_orders_user_id',
        'orders',
        'users',
        ['user_id'],
        ['id']
    )

def downgrade():
    op.drop_constraint('fk_orders_user_id', 'orders', type_='foreignkey')
    op.drop_column('orders', 'user_id')
```

## Migration Organization

### Branching Strategy

```
main branch
‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îú‚îÄ‚îÄ versions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 001_initial.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 002_add_users.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 003_add_orders.py
```

### Multiple Heads (Avoid)

```bash
# Detect multiple heads
alembic heads

# Merge heads
alembic merge -m "Merge user and order migrations" heads
```

## Testing Migrations

### Test Migration Up/Down

```python
# tests/test_migrations.py
import pytest
from alembic import command
from alembic.config import Config

@pytest.fixture
def alembic_cfg():
    return Config("alembic.ini")

def test_migrations_up_and_down(alembic_cfg):
    # Upgrade to head
    command.upgrade(alembic_cfg, "head")
    
    # Downgrade one step
    command.downgrade(alembic_cfg, "-1")
    
    # Upgrade again
    command.upgrade(alembic_cfg, "+1")
```

## Deployment Strategy

### Production Deployment

```bash
# 1. Backup database
pg_dump database_name > backup.sql

# 2. Review pending migrations
alembic current
alembic heads

# 3. Apply migrations
alembic upgrade head

# 4. Verify
alembic current
```

### Zero-Downtime Migrations

```python
# Strategy 1: Add nullable column
def upgrade():
    op.add_column('users', sa.Column('new_field', sa.String(), nullable=True))
    # Application code handles both old and new
    # Later: Make NOT NULL in separate migration

# Strategy 2: New table, then migrate
def upgrade():
    op.create_table('users_v2', ...)  # New table
    # Application writes to both
    # Migrate data gradually
    # Switch reads, then drop old table
```

## Best Practices Summary

1. **Always review autogenerated migrations**
2. **Write reversible downgrades**
3. **Separate schema and data migrations**
4. **Test migrations in staging first**
5. **Backup before production migrations**
6. **Use transactions (default in Alembic)**
7. **Version control migration files**
8. **Document complex migrations**
9. **Avoid breaking changes in production**
10. **Plan zero-downtime strategies**

## Summary

Alembic migrations should be:
- ‚úÖ Reversible (downgrade works)
- ‚úÖ Reviewed (never blindly accept autogenerate)
- ‚úÖ Tested (in staging environment)
- ‚úÖ Documented (complex changes explained)
- ‚úÖ Safe (backups, transactions, zero-downtime)

Following these practices ensures smooth database schema evolution in production.

---

## üéØ Interview Questions: FastAPI

### Q1: Explain Alembic migrations in FastAPI, including how they work, creating migrations, upgrading/downgrading, handling conflicts, and best practices for production deployments. Provide detailed examples showing migration patterns.

**Answer:**

**Alembic Overview:**

Alembic is SQLAlchemy's database migration tool that manages schema changes over time. It tracks database versions, generates migration scripts, and applies changes safely.

**Why Alembic:**

**Without Migrations (Manual Changes):**
```python
# ‚ùå Bad: Manual schema changes
# Developer 1: ALTER TABLE users ADD COLUMN email VARCHAR(255);
# Developer 2: ALTER TABLE users ADD COLUMN phone VARCHAR(20);
# Problem: No version control, conflicts, can't rollback
```

**With Alembic (Versioned Changes):**
```python
# ‚úÖ Good: Versioned migrations
# alembic revision --autogenerate -m "add email column"
# alembic upgrade head
# Benefits: Version control, rollback, conflict resolution
```

**Creating Migrations:**

**Autogenerate Migration:**
```bash
# Generate migration from model changes
alembic revision --autogenerate -m "add users table"
```

**Manual Migration:**
```python
# Create empty migration
alembic revision -m "add custom index"

# Edit migration file
def upgrade():
    op.create_index('idx_users_email', 'users', ['email'])

def downgrade():
    op.drop_index('idx_users_email', 'users')
```

**Migration Structure:**
```python
"""add users table

Revision ID: 001
Revises: 
Create Date: 2024-01-01 12:00:00
"""
from alembic import op
import sqlalchemy as sa

def upgrade():
    op.create_table('users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('email', sa.String(255), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )

def downgrade():
    op.drop_table('users')
```

**Upgrading and Downgrading:**
```bash
# Upgrade to latest
alembic upgrade head

# Upgrade one step
alembic upgrade +1

# Downgrade one step
alembic downgrade -1

# Downgrade to specific revision
alembic downgrade 001

# Show current version
alembic current
```

**Handling Conflicts:**

**Multiple Heads:**
```bash
# Detect multiple heads
alembic heads

# Merge heads
alembic merge -m "Merge user and order migrations" heads
```

**Zero-Downtime Migrations:**
```python
# Strategy 1: Add nullable column
def upgrade():
    op.add_column('users', sa.Column('new_field', sa.String(), nullable=True))
    # Application handles both old and new
    # Later: Make NOT NULL in separate migration

# Strategy 2: New table, then migrate
def upgrade():
    op.create_table('users_v2', ...)  # New table
    # Application writes to both
    # Migrate data gradually
    # Switch reads, then drop old table
```

**Best Practices:**

**1. Always Review Autogenerated Migrations:**
```python
# Review before applying
# Fix incorrect changes
# Add data migrations if needed
```

**2. Write Reversible Downgrades:**
```python
def upgrade():
    op.add_column('users', sa.Column('email', sa.String(255)))

def downgrade():
    op.drop_column('users', 'email')  # Must be reversible
```

**3. Separate Schema and Data Migrations:**
```python
# Schema migration
def upgrade():
    op.add_column('users', sa.Column('status', sa.String(50)))

# Data migration (separate file)
def upgrade():
    op.execute("UPDATE users SET status = 'active' WHERE status IS NULL")
```

**4. Test Migrations:**
```python
# Test in staging first
# Test upgrade and downgrade
# Verify data integrity
```

**System Design Consideration**: Alembic provides:
1. **Version Control**: Track schema changes
2. **Rollback**: Revert changes if needed
3. **Collaboration**: Multiple developers can work safely
4. **Production Safety**: Tested migrations before deployment

Alembic is essential for managing database schema evolution. Understanding migration creation, upgrading/downgrading, conflict resolution, and best practices is crucial for safe database changes in production.

---

### Q2: Explain zero-downtime migrations, handling data migrations, testing migrations, and deployment strategies. Discuss common pitfalls and how to avoid them.

**Answer:**

**Zero-Downtime Migrations:**

**Strategy 1: Add Nullable Column:**
```python
# Step 1: Add nullable column
def upgrade():
    op.add_column('users', sa.Column('new_field', sa.String(), nullable=True))

# Step 2: Populate data (separate migration)
def upgrade():
    op.execute("UPDATE users SET new_field = 'default' WHERE new_field IS NULL")

# Step 3: Make NOT NULL (separate migration)
def upgrade():
    op.alter_column('users', 'new_field', nullable=False)
```

**Strategy 2: New Table Migration:**
```python
# Step 1: Create new table
def upgrade():
    op.create_table('users_v2', ...)

# Step 2: Dual write (application writes to both)
# Step 3: Migrate data gradually
# Step 4: Switch reads to new table
# Step 5: Drop old table
```

**Data Migrations:**
```python
# Separate data migrations from schema migrations
def upgrade():
    # Migrate existing data
    op.execute("""
        UPDATE orders 
        SET status = 'completed' 
        WHERE status = 'done'
    """)
```

**Testing Migrations:**
```python
# Test upgrade and downgrade
def test_migrations():
    # Upgrade to head
    alembic.upgrade("head")
    
    # Verify schema
    assert table_exists('users')
    
    # Downgrade
    alembic.downgrade("-1")
    
    # Verify rollback
    assert not table_exists('users')
```

**Deployment Strategy:**
```bash
# 1. Backup database
pg_dump database_name > backup.sql

# 2. Review pending migrations
alembic current
alembic heads

# 3. Apply migrations
alembic upgrade head

# 4. Verify
alembic current
```

**Common Pitfalls:**

**1. Breaking Changes:**
```python
# ‚ùå Bad: Remove column immediately
def upgrade():
    op.drop_column('users', 'old_field')  # Breaks application

# ‚úÖ Good: Deprecate first, remove later
def upgrade():
    # Mark as deprecated, remove in future migration
    pass
```

**2. Non-Reversible Migrations:**
```python
# ‚ùå Bad: No downgrade
def upgrade():
    op.execute("DELETE FROM users WHERE status = 'inactive'")

# ‚úÖ Good: Reversible
def upgrade():
    op.execute("DELETE FROM users WHERE status = 'inactive'")

def downgrade():
    # Can't restore deleted data, but document it
    pass
```

**System Design Consideration**: Zero-downtime migrations require:
1. **Planning**: Multi-step migrations
2. **Testing**: Test in staging first
3. **Backups**: Always backup before migrations
4. **Monitoring**: Monitor during migration

Understanding zero-downtime migrations, data migrations, testing, and deployment strategies is essential for safe database changes in production. Always plan multi-step migrations, test thoroughly, and have rollback plans.


